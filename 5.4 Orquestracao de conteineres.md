### **Orquestração de Contêineres: Docker Swarm e Kubernetes**

A orquestração de contêineres é essencial para gerenciar múltiplos contêineres em ambientes distribuídos. Ferramentas como **Docker Swarm** e **Kubernetes** possibilitam a automação da implantação, escalonamento e gerenciamento de contêineres, garantindo alta disponibilidade e eficiência operacional.

---

### **1. Conceito de Orquestração de Contêineres**

A orquestração de contêineres envolve:

- **Gerenciamento de múltiplos contêineres** de forma distribuída.
- **Escalonamento automático**, aumentando ou reduzindo instâncias conforme a demanda.
- **Balanceamento de carga** entre os serviços.
- **Monitoramento e reinício automático** de contêineres com falhas.
- **Distribuição eficiente de recursos** entre nós de um cluster.

---

### **2. Docker Swarm: Orquestração Nativa do Docker**

Docker Swarm é uma solução de orquestração integrada ao Docker, permitindo criar e gerenciar clusters de contêineres de maneira simplificada.

#### **Comandos Básicos no Docker Swarm**

1. Inicializar um cluster Swarm:
```sh
docker swarm init
```
2. Adicionar nós ao cluster:
```sh
docker swarm join --token <TOKEN> <IP_DO_MANAGER>:2377
```
3. Criar um serviço replicado:
```sh
docker service create --name webserver -p 8080:80 --replicas 3 nginx
```
4. Listar os serviços ativos:
```sh
docker service ls
```
5. Testar o acesso ao servidor web:
```sh
curl http://localhost:8080
```
6. Remover o Swarm:
```sh
docker swarm leave --force
```

---

### **3. Kubernetes: Configuração Completa com Minikube**

Kubernetes é uma plataforma avançada para gerenciar contêineres em um ambiente distribuído. Este tutorial guiará a configuração desde a instalação até a validação do funcionamento do serviço.

#### **Passo a Passo para Configuração no Kubernetes com Minikube**

1. Iniciar o Minikube:
```sh
minikube start
```
2. Verificar se o cluster está ativo:
```sh
kubectl cluster-info
```
3. Criar um Deployment para executar um servidor Nginx:
```sh
kubectl create deployment webserver --image=nginx
```
4. Expor o serviço via NodePort:
```sh
kubectl expose deployment webserver --type=NodePort --port=80
```
5. Listar os serviços e verificar a porta atribuída:
```sh
kubectl get services
```
6. Descobrir o IP do Minikube:
```sh
minikube ip
```
7. Testar o acesso ao serviço e identificar o nó respondendo:
```sh
for i in {1..5}; do curl -s -w "
Respondendo de: %{remote_ip}
" http://$(minikube ip):$(kubectl get service webserver -o=jsonpath='{.spec.ports[0].nodePort}'); done
```
8. Caso necessário, utilizar o port-forward:
```sh
kubectl port-forward svc/webserver 8080:80
```
E testar o acesso localmente:
```sh
curl http://localhost:8080
```
9. Escalar o número de réplicas:
```sh
kubectl scale deployment webserver --replicas=3
```
10. Remover o cluster Minikube:
```sh
minikube delete
```

---

### **4. Comparação entre Docker Swarm e Kubernetes**

| Recurso                | Docker Swarm     | Kubernetes                     |
| ---------------------- | ---------------- | ------------------------------ |
| Facilidade de uso      | Simples e rápido | Mais complexo                  |
| Escalabilidade         | Limitada         | Alta escalabilidade            |
| Monitoramento          | Básico           | Avançado (Prometheus, Grafana) |
| Balanceamento de carga | Automático       | Requer configuração            |
| Recuperação de falhas  | Básico           | Automático e robusto           |
| Integração com nuvem   | Limitada         | Suporte amplo                  |

---

### **5. Testando a Resiliência e Recuperação de Contêineres**

#### **Testando a Resiliência no Docker Swarm**

1. Listar os contêineres ativos:
```sh
docker service ps webserver
```
2. Matar um dos contêineres:
```sh
docker rm -f <CONTAINER_ID>
```
3. Verificar se um novo contêiner foi iniciado automaticamente:
```sh
docker service ps webserver
```

#### **Testando a Resiliência no Kubernetes**

1. Listar os pods ativos:
```sh
kubectl get pods
```
2. Deletar um pod manualmente:
```sh
kubectl delete pod <POD_NAME>
```
3. Verificar se um novo pod foi criado automaticamente:
```sh
kubectl get pods
```
4. Testar o acesso ao serviço após a recuperação:
```sh
curl http://$(minikube ip):$(kubectl get service webserver -o=jsonpath='{.spec.ports[0].nodePort}')
```

---

### **6. Conclusão**

A escolha entre Docker Swarm e Kubernetes depende das necessidades do projeto:

- **Docker Swarm** é mais simples e ideal para pequenas implantações.
- **Kubernetes** é mais robusto, indicado para grandes arquiteturas distribuídas e aplicações empresariais.

A adoção de um orquestrador é fundamental para garantir escalabilidade, resiliência e eficiência na execução de contêineres em ambientes modernos.

